{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","PathfindingVisualizer/Node/images/weight.png","PathfindingVisualizer/Node/images/visitedWeight.png","PathfindingVisualizer/Node/images/pathWeight.png","PathfindingVisualizer/Tutorial/Tutorial.jsx","PathfindingVisualizer/Node/images/start.png","PathfindingVisualizer/Node/images/end.png","algorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","isWeight","extraClassName","id","className","Component","Tutorial","document","addEventListener","name","chunks","cookie","split","i","length","trim","getCookie","showPopUp","console","log","value","escape","setCookie","skipPopUp","onClick","htmlFor","src","alt","style","background","backgroundColor","weight","visitedWeight","pathWeight","elem","querySelector","pathfindingVisualizer","display","filter","dijkstra","grid","startNode","endNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","neighbor","getUnvisitedNeighbors","previousNode","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","weightChangeHandler","event","setState","target","pointChangeHandler","notCorrect","getElementById","parseInt","isNaN","toggleWeight","temp","changeWeight","mouseIsPressed","topMessage","distanceToBeTraveled","getInitialGrid","newGrid","getNewGridWithWeightToggled","getNewGridWithWallToggled","finishNode","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","setTimeout","animateShortestPath","timeTaken","button_task","visualizeDijkstra","href","window","location","reload","changeWeightText","textBox","type","min","max","onChange","defaultValue","row_max_length","col_max_length","width","margin","borderSpacing","map","rowIndex","nodeIndex","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.50b47215.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    const {\n      row,\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      isWeight,\n    } = this.props;\n\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : isWeight\n      ? \"node-weight\"\n      : \"\";\n\n    return (\n      <td\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></td> // It is used to create the grid.\n    );\n  }\n}\n","export default __webpack_public_path__ + \"static/media/weight.bbee2b2e.png\";","export default __webpack_public_path__ + \"static/media/visitedWeight.eabc14b1.png\";","export default __webpack_public_path__ + \"static/media/pathWeight.f0c75b52.png\";","import React, { Component } from \"react\";\n\nimport start from \"../Node/images/start.png\"; // Tell webpack this JS file uses this image\nimport end from \"../Node/images/end.png\";\nimport weight from \"../Node/images/weight.png\";\nimport visitedWeight from \"../Node/images/visitedWeight.png\";\nimport pathWeight from \"../Node/images/pathWeight.png\";\n\nimport \"./Tutorial.css\";\n\nexport class Tutorial extends Component {\n  componentDidMount() {\n    document.addEventListener(\"DOMContentLoaded\", function () {\n      if (getCookie(\"visited\") == null) {\n        //shows tutorial only if cookie is absent\n        // if (true) {\n        showPopUp();\n        console.log(\"h\");\n        setCookie(\"visited\", true);\n      } else {\n        skipPopUp();\n      }\n    });\n  }\n  render() {\n    return (\n      <div className=\"PopUpTextBox\">\n        <header>\n          <p>Quick Walkthrough to Visualizer</p>\n          <h3 onClick={skipPopUp}>x</h3>\n        </header>\n\n        <div className=\"PopUpIntroductionText\">\n          {/* <h3>Quick Walkthrough to Visualizer</h3> */}\n          <div className=\"player\">\n            <label htmlFor=\"start\">Start : </label>\n            <img src={start} name=\"start\" alt=\"\" />\n\n            <label htmlFor=\"end\">End : </label>\n            <img src={end} name=\"end\" alt=\"\" />\n\n            <label htmlFor=\"wall\">Wall : </label>\n            <div style={{ background: \"black\" }} name=\"wall\"></div>\n\n            <label htmlFor=\"wall\">Visited Node : </label>\n            <div\n              style={{ backgroundColor: \"rgba(0, 190, 218, 0.75)\" }}\n              name=\"wall\"\n            ></div>\n\n            <label htmlFor=\"weight\">Weight : </label>\n            <img src={weight} name=\"weight\" alt=\"\" />\n\n            <label htmlFor=\"visitedWeight\">Visited Weight : </label>\n            <img src={visitedWeight} name=\"visitedWeight\" alt=\"\" />\n\n            <label htmlFor=\"pathWeight\">Weight on Path : </label>\n            <img src={pathWeight} name=\"pathWeight\" alt=\"\" />\n          </div>\n          <div></div>\n        </div>\n\n        <div className=\"skipBox\">\n          <small>\n            View this anytime by clicking on <span>[Search Visualizer]</span>\n          </small>\n          <button onClick={skipPopUp}>Visualize !</button>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport const skipPopUp = () => {\n  const elem = document.querySelector(\".PopUp\");\n  const pathfindingVisualizer = document.querySelector(\n    \".pathfindingVisualizer\"\n  );\n  elem.style.display = \"none\";\n  pathfindingVisualizer.style.filter = \"none\";\n};\n\nexport const showPopUp = () => {\n  const elem = document.querySelector(\".PopUp\");\n  const pathfindingVisualizer = document.querySelector(\n    \".pathfindingVisualizer\"\n  );\n  elem.style.display = \"block\";\n  pathfindingVisualizer.style.filter = \" blur(4px)\";\n};\n\n///////////////////////////////////////////////////////////////////\nfunction setCookie(name, value) {\n  var cookie = name + \"=\" + escape(value) + \";\";\n  document.cookie = cookie;\n}\n\nfunction getCookie(name) {\n  var chunks = document.cookie.split(\";\");\n  for (var i = chunks.length; i--; ) {\n    if (chunks[i].trim().split(\"=\")[0].trim() === name) {\n      return chunks[i].trim().split(\"=\")[1].trim();\n    }\n  }\n  return null;\n}\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAyCAYAAADMb4LpAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAADiSURBVGhD7dk7DsIwFERRm/3vGRiRNEgYKW8+sfRuA+UZ40DBfL4bm/Y4Xres8akan6rxqUrf83PO490n908G9eS/x6ijXxvnAMmddw0o4Vd33DGgfPLJAZRrkxpAu/OJAdQH1j2AikfOAXQ8cg2Q4JFjgAyP1AOkeKQcIMcj1QALHikG2PD/ujLgNvjVJ/MrG351slfgyIJXwJEcr4IjKV4JRzK8Go4keAcc0fEuOKLinXBEw7vhiIJPwFEZn4KjEj4JR9QH9swBR3S8C46oeCcc9Z/IqRqfqvGpGp9qY/wYL15AY1ZQGcX3AAAAAElFTkSuQmCC\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAAzCAYAAADciPtuAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAHfSURBVGhD7ZhdSgMxFEZnXEbBF7ej4FoLuh1fBLdRvTApMeT+f0nbYQ6IgzQ3Ob1f0tT18seyQ56237vjEHs0hu2xdV23pz6jtzZMTBPRQIumxbJCLSjB1B5DSxFUE1E3JIaaXCJb3x1F64SfP8/bU5/X0/f2JBONpktMk9JkODTJiJw5iqOkCG1sJJamjkmFM0I9pO55Opc6FdFShFTT0zlVjCs2QqqAqC1GESHVi5Z1PBdLSySHiFmPciJSyyLGRnGGFOF9PWHZa67DAy1VkMZZY9uSOhVrolKF7PgWiBhqUZ46Why7Yr1B0UggiMwNi6LEy/nt+jOLtJgWn1ZGk0PFemjHOIkZnZsSxVtwiEX4ev/Ynv7D/R1JWkw7ilsJTQr1sdK9BHvvichbQ28Orr50Ge52zHJ7vjXaGiF7DBUfVB3CJSZFLrsodMxZMa7VI+S84yxbBRLFGu8ipddnDiX132/Rb9KF3uIsYzkpS7eIsBjh7Y4VqVNWMTWKUqFMVDgQUoRpj82SQ0kRahRrtK/j0Whqb45XinCJEZpcQZO0djoiRbjFCKtclqgUEfocy0xoJTtHqGM16O6h3rS0WCEriBIqwMRqrJIDpr4yROwegF+C74VD7NHYqdiy/AJyZxGoWjSDUQAAAABJRU5ErkJggg==\"","// Implementing dijkstra algorithm.\n// Dijkstra is a weighted algorithm,weights are non-negative in this algorithm.\n\n// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n\nexport function dijkstra(grid, startNode, endNode) {\n  const visitedNodesInOrder = []; // To animate visited nodes in order to animate the process of searching.\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue; // Here isWall is the property of the node.\n\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n\n    visitedNodesInOrder.push(closestNode);\n\n    // Checking for the success condition.\n    if (closestNode === endNode) return visitedNodesInOrder;\n\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\n// Sorts the unvisitedNodes every time it is called.\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\n// Sets the neighbour nodes distance and also the previous node property.\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + neighbor.weight + 1;\n    // Now the neighbor distance is not infinity and because of it it will show among the top in unvisited nodes.\n    neighbor.previousNode = node; // With this property we can backtrack and find the shortest path between the start and end node.\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node; //col and row are properties of the node.\n\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\n  return neighbors.filter((neighbor) => !neighbor.isVisited); // filtering the visited node\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { Component } from \"react\";\n\nimport Node from \"./Node/Node.jsx\";\nimport { showPopUp } from \"./Tutorial/Tutorial.jsx\";\n\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\n\nimport \"./PathfindingVisualizer.css\";\n\n// Defining initial state of start and finish.\n\nlet row_max_length = 20;\nlet col_max_length = 40;\n\nlet START_NODE_ROW = 9;\nlet START_NODE_COL = 8;\nlet FINISH_NODE_ROW = 9;\nlet FINISH_NODE_COL = 31;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      topMessage: \"Dijkstra Algorithm\",\n      weight: 1,\n      changeWeight: true,\n      distanceToBeTraveled: 0,\n    };\n  }\n\n  // Creating grid\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  // On pressing the mouse down\n  handleMouseDown(row, col) {\n    if (this.state.topMessage !== \"Dijkstra Algorithm\") return;\n\n    let newGrid = [];\n\n    if (this.state.changeWeight) {\n      newGrid = getNewGridWithWeightToggled(\n        this.state.grid,\n        row,\n        col,\n        this.state.weight\n      );\n    } else {\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    }\n\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  // On entering the new node element.\n  handleMouseEnter(row, col) {\n    if (this.state.topMessage !== \"Dijkstra Algorithm\") return;\n    if (!this.state.mouseIsPressed) return;\n\n    let newGrid = [];\n\n    if (this.state.changeWeight) {\n      newGrid = getNewGridWithWeightToggled(\n        this.state.grid,\n        row,\n        col,\n        this.state.weight\n      );\n    } else {\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    }\n\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  // When we release the mouse\n  handleMouseUp() {\n    if (this.state.topMessage !== \"Dijkstra Algorithm\") return;\n    this.setState({ mouseIsPressed: false });\n  }\n\n  visualizeDijkstra() {\n    this.setState({ topMessage: \"Dijkstra OP\" });\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      // When we reach the last element in visitedNodesInOrder.\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.setState({ topMessage: \"Shortest Path\" });\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n\n      if (i === visitedNodesInOrder.length - 1) continue;\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node.isWeight) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visitedWeight\";\n        } else {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    let timeTaken = 0;\n    for (let i = 1; i < nodesInShortestPathOrder.length - 1; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        if (nodesInShortestPathOrder[i].isWeight) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-path-weight\";\n        } else {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-path\";\n        }\n      }, 50 * i);\n    }\n\n    timeTaken =\n      nodesInShortestPathOrder[nodesInShortestPathOrder.length - 1].distance;\n    this.setState({ distanceToBeTraveled: timeTaken });\n  }\n\n  // onClick={() => this.resetGrid()}\n  // resetGrid() {\n\n  //   const newGrid = getInitialGrid();\n\n  //   START_NODE_ROW = 0;\n  //   START_NODE_COL = 0;\n  //   FINISH_NODE_ROW = row_max_length - 1;\n  //   FINISH_NODE_COL = col_max_length - 1;\n\n  //   document.getElementById(\"start_row\").value = START_NODE_ROW;\n  //   document.getElementById(\"start_col\").value = START_NODE_COL;\n  //   document.getElementById(\"end_row\").value = FINISH_NODE_ROW;\n  //   document.getElementById(\"end_col\").value = FINISH_NODE_COL;\n\n  //   for (let row = 0; row < row_max_length; row++) {\n  //     for (let col = 0; col < col_max_length; col++) {\n  //       if (row === START_NODE_ROW && col === START_NODE_COL) {\n  //         document.getElementById(`node-${row}-${col}`).className =\n  //           \"node node-start\";\n  //       } else if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\n  //         document.getElementById(`node-${row}-${col}`).className =\n  //           \"node node-finish\";\n  //       } else {\n  //         document.getElementById(`node-${row}-${col}`).className = \"node\";\n  //       }\n  //     }\n  //   }\n  //   this.setState({ topMessage: \"Dijkstra Algorithm\" });\n\n  //   this.setState({ grid: newGrid });\n  // }\n\n  weightChangeHandler = (event) => {\n    this.setState({ weight: event.target.value });\n  };\n\n  pointChangeHandler = () => {\n    if (this.notCorrect()) return; //To check if the provided value is suitable or not.\n\n    document.getElementById(\n      `node-${START_NODE_ROW}-${START_NODE_COL}`\n    ).className = \"node\";\n    document.getElementById(\n      `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\n    ).className = \"node\";\n\n    START_NODE_ROW = parseInt(document.getElementById(\"start_row\").value);\n    START_NODE_COL = parseInt(document.getElementById(\"start_col\").value);\n    FINISH_NODE_ROW = parseInt(document.getElementById(\"end_row\").value);\n    FINISH_NODE_COL = parseInt(document.getElementById(\"end_col\").value);\n\n    document.getElementById(\n      `node-${START_NODE_ROW}-${START_NODE_COL}`\n    ).className = \"node node-start\";\n    document.getElementById(\n      `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\n    ).className = \"node node-finish\";\n  };\n\n  notCorrect = () => {\n    if (\n      isNaN(parseInt(document.getElementById(\"start_row\").value)) ||\n      isNaN(parseInt(document.getElementById(\"start_col\").value)) ||\n      isNaN(parseInt(document.getElementById(\"end_row\").value)) ||\n      isNaN(parseInt(document.getElementById(\"end_col\").value))\n    )\n      return true;\n\n    if (\n      parseInt(document.getElementById(\"start_row\").value) > row_max_length ||\n      parseInt(document.getElementById(\"start_col\").value) > col_max_length\n    )\n      return true;\n    if (\n      parseInt(document.getElementById(\"start_row\").value) < 0 ||\n      parseInt(document.getElementById(\"start_col\").value) < 0\n    )\n      return true;\n\n    if (\n      parseInt(document.getElementById(\"end_row\").value) > row_max_length ||\n      parseInt(document.getElementById(\"end_col\").value) > col_max_length\n    )\n      return true;\n    if (\n      parseInt(document.getElementById(\"end_row\").value) < 0 ||\n      parseInt(document.getElementById(\"end_col\").value) < 0\n    )\n      return true;\n\n    return false;\n  };\n\n  toggleWeight = () => {\n    const temp = this.state.changeWeight;\n    this.setState({ changeWeight: !temp });\n  };\n\n  render() {\n    const { grid, mouseIsPressed, topMessage, distanceToBeTraveled } =\n      this.state;\n    let button_task = (\n      <p className=\"btn\" onClick={() => this.visualizeDijkstra()}>\n        Start Dijkstra Algorithm\n      </p>\n    );\n\n    if (topMessage === \"Shortest Path\") {\n      button_task = (\n        <h2\n          className=\"btn\"\n          href=\"#\"\n          onClick={() => window.location.reload(false)}\n        >\n          Reset Grid <br />\n          Weighted Distance : {distanceToBeTraveled}\n          {/* <small> [1 Block = 1 Time = 1 Weight]</small> */}\n        </h2>\n      );\n    } else if (topMessage === \"Dijkstra OP\") {\n      button_task = <h3 className=\"running\">Running...</h3>;\n    }\n\n    let changeWeightText = \"False\";\n\n    if (this.state.changeWeight) changeWeightText = \"True\";\n\n    let textBox = (\n      <div className=\"textBox\">\n        <div className=\"weightContainer\">\n          <label htmlFor=\"quantity\">Toggle/Set Weight </label>\n\n          <input\n            type=\"number\"\n            id=\"quantity\"\n            name=\"quantity\"\n            min=\"1\"\n            max=\"5\"\n            onChange={this.weightChangeHandler}\n            defaultValue=\"1\"\n          />\n\n          <button onClick={this.toggleWeight}>{changeWeightText}</button>\n        </div>\n\n        <div className=\"startPointContainer\">\n          <label htmlFor=\"point\">Start Point :</label>\n          <input\n            type=\"number\"\n            name=\"point\"\n            id=\"start_row\"\n            min=\"0\"\n            max={row_max_length - 1}\n            onChange={this.pointChangeHandler}\n            defaultValue=\"9\"\n          ></input>\n          <input\n            type=\"number\"\n            name=\"point\"\n            id=\"start_col\"\n            min=\"0\"\n            max={col_max_length - 1}\n            onChange={this.pointChangeHandler}\n            defaultValue=\"8\"\n          ></input>\n        </div>\n\n        <div className=\"endPointContainer\">\n          <label htmlFor=\"point\">End Point :</label>\n          <input\n            type=\"number\"\n            name=\"point\"\n            id=\"end_row\"\n            min=\"0\"\n            max={row_max_length - 1}\n            onChange={this.pointChangeHandler}\n            defaultValue=\"9\"\n          ></input>\n          <input\n            type=\"number\"\n            name=\"point\"\n            id=\"end_col\"\n            min=\"0\"\n            max={col_max_length - 1}\n            onChange={this.pointChangeHandler}\n            defaultValue=\"31\"\n          ></input>\n        </div>\n\n        <div className=\"buttonContainer\">{button_task}</div>\n      </div>\n    );\n\n    if (topMessage === \"Dijkstra OP\") {\n      textBox = null;\n    } else if (topMessage === \"Shortest Path\") {\n      textBox = (\n        <div\n          className=\"buttonContainer\"\n          style={{ width: \"30%\", margin: \"0 auto\" }}\n        >\n          {button_task}\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"pathfindingVisualizer\">\n        <div className=\"container\">\n          <div className=\"heading\">\n            <h2 onClick={showPopUp}>Search Visualizer</h2>\n            <h2>{topMessage}</h2>\n          </div>\n\n          {/* Show the header */}\n          {textBox}\n\n          <p>\n            Dijkstra's Algorithm is weighted and guarantees the shortest path!{\" \"}\n            <span className=\"ref\"></span>\n          </p>\n        </div>\n\n        <div className=\"visualGridContainer\">\n          <div className=\"gridBox\">\n            <table className=\"grid\" style={{ borderSpacing: \"0\" }}>\n              <tbody>\n                {grid.map((row, rowIndex) => {\n                  return (\n                    <tr key={rowIndex}>\n                      {row.map((node, nodeIndex) => {\n                        const { isStart, isFinish, isWall, isWeight } = node; //Extracting from the node\n                        return (\n                          <Node\n                            row={rowIndex}\n                            col={nodeIndex}\n                            key={rowIndex + \"-\" + nodeIndex}\n                            isStart={isStart}\n                            isFinish={isFinish}\n                            isWall={isWall}\n                            isWeight={isWeight}\n                            mouseIsPressed={mouseIsPressed}\n                            onMouseDown={(row, col) =>\n                              this.handleMouseDown(row, col)\n                            }\n                            onMouseEnter={(row, col) =>\n                              this.handleMouseEnter(row, col)\n                            }\n                            onMouseUp={() => this.handleMouseUp()}\n                          ></Node>\n                        );\n                      })}\n                    </tr>\n                  );\n                })}\n              </tbody>\n            </table>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < row_max_length; row++) {\n    const currentRow = [];\n    for (let col = 0; col < col_max_length; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    isWeight: false,\n    previousNode: null,\n    weight: 0,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = [...grid];\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node, // copying other properties of the node\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithWeightToggled = (grid, row, col, weight) => {\n  const newGrid = [...grid];\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node, // copying other properties of the node\n    isWeight: !node.isWeight,\n    weight: parseInt(weight),\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","import \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer.jsx\";\nimport {Tutorial} from \"./PathfindingVisualizer/Tutorial/Tutorial.jsx\";\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n      <div className=\"PopUp\">\n        <Tutorial />\n      </div>\n    </div>\n    \n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}